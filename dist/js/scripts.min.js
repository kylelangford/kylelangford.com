/*!
* headroom.js v0.7.0 - Give your page some headroom. Hide your header until you need it
* Copyright (c) 2014 Nick Williams - http://wicky.nillia.ms/headroom.js
* License: MIT
*/
(function(a, b) {
    "use strict";
    /* exported features */
    var c = {
        bind: !!function() {}.bind,
        classList: "classList" in b.documentElement,
        rAF: !!(a.requestAnimationFrame || a.webkitRequestAnimationFrame || a.mozRequestAnimationFrame)
    };
    a.requestAnimationFrame = a.requestAnimationFrame || a.webkitRequestAnimationFrame || a.mozRequestAnimationFrame;
    /**
* Handles debouncing of events via requestAnimationFrame
* @see http://www.html5rocks.com/en/tutorials/speed/animations/
* @param {Function} callback The callback to handle whichever event
*/
    function d(a) {
        this.callback = a;
        this.ticking = false;
    }
    d.prototype = {
        constructor: d,
        /**
* dispatches the event to the supplied callback
* @private
*/
        update: function() {
            this.callback && this.callback();
            this.ticking = false;
        },
        /**
* ensures events don't get stacked
* @private
*/
        requestTick: function() {
            if (!this.ticking) {
                requestAnimationFrame(this.rafCallback || (this.rafCallback = this.update.bind(this)));
                this.ticking = true;
            }
        },
        /**
* Attach this as the event listeners
*/
        handleEvent: function() {
            this.requestTick();
        }
    };
    /**
* Check if object is part of the DOM
* @constructor
* @param {Object} obj element to check
*/
    function e(b) {
        return b && typeof a !== "undefined" && (b === a || b.nodeType);
    }
    /**
* Helper function for extending objects
*/
    function f(a) {
        if (arguments.length <= 0) {
            throw new Error("Missing arguments in extend function");
        }
        var b = a || {}, c, d;
        for (d = 1; d < arguments.length; d++) {
            var g = arguments[d] || {};
            for (c in g) {
                // Recurse into object except if the object is a DOM element
                if (typeof b[c] === "object" && !e(b[c])) {
                    b[c] = f(b[c], g[c]);
                } else {
                    b[c] = b[c] || g[c];
                }
            }
        }
        return b;
    }
    /**
* Helper function for normalizing tolerance option to object format
*/
    function g(a) {
        return a === Object(a) ? a : {
            down: a,
            up: a
        };
    }
    /**
* UI enhancement for fixed headers.
* Hides header when scrolling down
* Shows header when scrolling up
* @constructor
* @param {DOMElement} elem the header element
* @param {Object} options options for the widget
*/
    function h(a, b) {
        b = f(b, h.options);
        this.lastKnownScrollY = 0;
        this.elem = a;
        this.debouncer = new d(this.update.bind(this));
        this.tolerance = g(b.tolerance);
        this.classes = b.classes;
        this.offset = b.offset;
        this.scroller = b.scroller;
        this.initialised = false;
        this.onPin = b.onPin;
        this.onUnpin = b.onUnpin;
        this.onTop = b.onTop;
        this.onNotTop = b.onNotTop;
    }
    h.prototype = {
        constructor: h,
        /**
* Initialises the widget
*/
        init: function() {
            if (!h.cutsTheMustard) {
                return;
            }
            this.elem.classList.add(this.classes.initial);
            // defer event registration to handle browser
            // potentially restoring previous scroll position
            setTimeout(this.attachEvent.bind(this), 100);
            return this;
        },
        /**
* Unattaches events and removes any classes that were added
*/
        destroy: function() {
            var a = this.classes;
            this.initialised = false;
            this.elem.classList.remove(a.unpinned, a.pinned, a.top, a.initial);
            this.scroller.removeEventListener("scroll", this.debouncer, false);
        },
        /**
* Attaches the scroll event
* @private
*/
        attachEvent: function() {
            if (!this.initialised) {
                this.lastKnownScrollY = this.getScrollY();
                this.initialised = true;
                this.scroller.addEventListener("scroll", this.debouncer, false);
                this.debouncer.handleEvent();
            }
        },
        /**
* Unpins the header if it's currently pinned
*/
        unpin: function() {
            var a = this.elem.classList, b = this.classes;
            if (a.contains(b.pinned) || !a.contains(b.unpinned)) {
                a.add(b.unpinned);
                a.remove(b.pinned);
                this.onUnpin && this.onUnpin.call(this);
            }
        },
        /**
* Pins the header if it's currently unpinned
*/
        pin: function() {
            var a = this.elem.classList, b = this.classes;
            if (a.contains(b.unpinned)) {
                a.remove(b.unpinned);
                a.add(b.pinned);
                this.onPin && this.onPin.call(this);
            }
        },
        /**
* Handles the top states
*/
        top: function() {
            var a = this.elem.classList, b = this.classes;
            if (!a.contains(b.top)) {
                a.add(b.top);
                a.remove(b.notTop);
                this.onTop && this.onTop.call(this);
            }
        },
        /**
* Handles the not top state
*/
        notTop: function() {
            var a = this.elem.classList, b = this.classes;
            if (!a.contains(b.notTop)) {
                a.add(b.notTop);
                a.remove(b.top);
                this.onNotTop && this.onNotTop.call(this);
            }
        },
        /**
* Gets the Y scroll position
* @see https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
* @return {Number} pixels the page has scrolled along the Y-axis
*/
        getScrollY: function() {
            return this.scroller.pageYOffset !== undefined ? this.scroller.pageYOffset : this.scroller.scrollTop !== undefined ? this.scroller.scrollTop : (b.documentElement || b.body.parentNode || b.body).scrollTop;
        },
        /**
* Gets the height of the viewport
* @see http://andylangton.co.uk/blog/development/get-viewport-size-width-and-height-javascript
* @return {int} the height of the viewport in pixels
*/
        getViewportHeight: function() {
            return a.innerHeight || b.documentElement.clientHeight || b.body.clientHeight;
        },
        /**
* Gets the height of the document
* @see http://james.padolsey.com/javascript/get-document-height-cross-browser/
* @return {int} the height of the document in pixels
*/
        getDocumentHeight: function() {
            var a = b.body, c = b.documentElement;
            return Math.max(a.scrollHeight, c.scrollHeight, a.offsetHeight, c.offsetHeight, a.clientHeight, c.clientHeight);
        },
        /**
* Gets the height of the DOM element
* @param  {Object}  elm the element to calculate the height of which
* @return {int}     the height of the element in pixels
*/
        getElementHeight: function(a) {
            return Math.max(a.scrollHeight, a.offsetHeight, a.clientHeight);
        },
        /**
* Gets the height of the scroller element
* @return {int} the height of the scroller element in pixels
*/
        getScrollerHeight: function() {
            return this.scroller === a || this.scroller === b.body ? this.getDocumentHeight() : this.getElementHeight(this.scroller);
        },
        /**
* determines if the scroll position is outside of document boundaries
* @param  {int}  currentScrollY the current y scroll position
* @return {bool} true if out of bounds, false otherwise
*/
        isOutOfBounds: function(a) {
            var b = a < 0, c = a + this.getViewportHeight() > this.getScrollerHeight();
            return b || c;
        },
        /**
* determines if the tolerance has been exceeded
* @param  {int} currentScrollY the current scroll y position
* @return {bool} true if tolerance exceeded, false otherwise
*/
        toleranceExceeded: function(a, b) {
            return Math.abs(a - this.lastKnownScrollY) >= this.tolerance[b];
        },
        /**
* determine if it is appropriate to unpin
* @param  {int} currentScrollY the current y scroll position
* @param  {bool} toleranceExceeded has the tolerance been exceeded?
* @return {bool} true if should unpin, false otherwise
*/
        shouldUnpin: function(a, b) {
            var c = a > this.lastKnownScrollY, d = a >= this.offset;
            return c && d && b;
        },
        /**
* determine if it is appropriate to pin
* @param  {int} currentScrollY the current y scroll position
* @param  {bool} toleranceExceeded has the tolerance been exceeded?
* @return {bool} true if should pin, false otherwise
*/
        shouldPin: function(a, b) {
            var c = a < this.lastKnownScrollY, d = a <= this.offset;
            return c && b || d;
        },
        /**
* Handles updating the state of the widget
*/
        update: function() {
            var a = this.getScrollY(), b = a > this.lastKnownScrollY ? "down" : "up", c = this.toleranceExceeded(a, b);
            if (this.isOutOfBounds(a)) {
                // Ignore bouncy scrolling in OSX
                return;
            }
            if (a <= this.offset) {
                this.top();
            } else {
                this.notTop();
            }
            if (this.shouldUnpin(a, c)) {
                this.unpin();
            } else if (this.shouldPin(a, c)) {
                this.pin();
            }
            this.lastKnownScrollY = a;
        }
    };
    /**
* Default options
* @type {Object}
*/
    h.options = {
        tolerance: {
            up: 0,
            down: 0
        },
        offset: 0,
        scroller: a,
        classes: {
            pinned: "headroom--pinned",
            unpinned: "headroom--unpinned",
            top: "headroom--top",
            notTop: "headroom--not-top",
            initial: "headroom"
        }
    };
    h.cutsTheMustard = typeof c !== "undefined" && c.rAF && c.bind && c.classList;
    a.Headroom = h;
})(window, document);

/*!
 * headroom.js v0.7.0 - Give your page some headroom. Hide your header until you need it
 * Copyright (c) 2014 Nick Williams - http://wicky.nillia.ms/headroom.js
 * License: MIT
 */
(function(a) {
    if (!a) {
        return;
    }
    ////////////
    // Plugin //
    ////////////
    a.fn.headroom = function(b) {
        return this.each(function() {
            var c = a(this), d = c.data("headroom"), e = typeof b === "object" && b;
            e = a.extend(true, {}, Headroom.options, e);
            if (!d) {
                d = new Headroom(this, e);
                d.init();
                c.data("headroom", d);
            }
            if (typeof b === "string") {
                d[b]();
            }
        });
    };
    //////////////
    // Data API //
    //////////////
    a("[data-headroom]").each(function() {
        var b = a(this);
        b.headroom(b.data());
    });
})(window.Zepto || window.jQuery);

/*!
Waypoints - 3.1.1
Copyright © 2011-2015 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blog/master/licenses.txt
*/
(function() {
    "use strict";
    var a = 0;
    var b = {};
    /* http://imakewebthings.com/waypoints/api/waypoint */
    function c(d) {
        if (!d) {
            throw new Error("No options passed to Waypoint constructor");
        }
        if (!d.element) {
            throw new Error("No element option passed to Waypoint constructor");
        }
        if (!d.handler) {
            throw new Error("No handler option passed to Waypoint constructor");
        }
        this.key = "waypoint-" + a;
        this.options = c.Adapter.extend({}, c.defaults, d);
        this.element = this.options.element;
        this.adapter = new c.Adapter(this.element);
        this.callback = d.handler;
        this.axis = this.options.horizontal ? "horizontal" : "vertical";
        this.enabled = this.options.enabled;
        this.triggerPoint = null;
        this.group = c.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        });
        this.context = c.Context.findOrCreateByElement(this.options.context);
        if (c.offsetAliases[this.options.offset]) {
            this.options.offset = c.offsetAliases[this.options.offset];
        }
        this.group.add(this);
        this.context.add(this);
        b[this.key] = this;
        a += 1;
    }
    /* Private */
    c.prototype.queueTrigger = function(a) {
        this.group.queueTrigger(this, a);
    };
    /* Private */
    c.prototype.trigger = function(a) {
        if (!this.enabled) {
            return;
        }
        if (this.callback) {
            this.callback.apply(this, a);
        }
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/destroy */
    c.prototype.destroy = function() {
        this.context.remove(this);
        this.group.remove(this);
        delete b[this.key];
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/disable */
    c.prototype.disable = function() {
        this.enabled = false;
        return this;
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/enable */
    c.prototype.enable = function() {
        this.context.refresh();
        this.enabled = true;
        return this;
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/next */
    c.prototype.next = function() {
        return this.group.next(this);
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/previous */
    c.prototype.previous = function() {
        return this.group.previous(this);
    };
    /* Private */
    c.invokeAll = function(a) {
        var c = [];
        for (var d in b) {
            c.push(b[d]);
        }
        for (var e = 0, f = c.length; e < f; e++) {
            c[e][a]();
        }
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/destroy-all */
    c.destroyAll = function() {
        c.invokeAll("destroy");
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/disable-all */
    c.disableAll = function() {
        c.invokeAll("disable");
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/enable-all */
    c.enableAll = function() {
        c.invokeAll("enable");
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/refresh-all */
    c.refreshAll = function() {
        c.Context.refreshAll();
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/viewport-height */
    c.viewportHeight = function() {
        return window.innerHeight || document.documentElement.clientHeight;
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/viewport-width */
    c.viewportWidth = function() {
        return document.documentElement.clientWidth;
    };
    c.adapters = [];
    c.defaults = {
        context: window,
        continuous: true,
        enabled: true,
        group: "default",
        horizontal: false,
        offset: 0
    };
    c.offsetAliases = {
        "bottom-in-view": function() {
            return this.context.innerHeight() - this.adapter.outerHeight();
        },
        "right-in-view": function() {
            return this.context.innerWidth() - this.adapter.outerWidth();
        }
    };
    window.Waypoint = c;
})();

(function() {
    "use strict";
    function a(a) {
        window.setTimeout(a, 1e3 / 60);
    }
    var b = 0;
    var c = {};
    var d = window.Waypoint;
    var e = window.onload;
    /* http://imakewebthings.com/waypoints/api/context */
    function f(a) {
        this.element = a;
        this.Adapter = d.Adapter;
        this.adapter = new this.Adapter(a);
        this.key = "waypoint-context-" + b;
        this.didScroll = false;
        this.didResize = false;
        this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        };
        this.waypoints = {
            vertical: {},
            horizontal: {}
        };
        a.waypointContextKey = this.key;
        c[a.waypointContextKey] = this;
        b += 1;
        this.createThrottledScrollHandler();
        this.createThrottledResizeHandler();
    }
    /* Private */
    f.prototype.add = function(a) {
        var b = a.options.horizontal ? "horizontal" : "vertical";
        this.waypoints[b][a.key] = a;
        this.refresh();
    };
    /* Private */
    f.prototype.checkEmpty = function() {
        var a = this.Adapter.isEmptyObject(this.waypoints.horizontal);
        var b = this.Adapter.isEmptyObject(this.waypoints.vertical);
        if (a && b) {
            this.adapter.off(".waypoints");
            delete c[this.key];
        }
    };
    /* Private */
    f.prototype.createThrottledResizeHandler = function() {
        var a = this;
        function b() {
            a.handleResize();
            a.didResize = false;
        }
        this.adapter.on("resize.waypoints", function() {
            if (!a.didResize) {
                a.didResize = true;
                d.requestAnimationFrame(b);
            }
        });
    };
    /* Private */
    f.prototype.createThrottledScrollHandler = function() {
        var a = this;
        function b() {
            a.handleScroll();
            a.didScroll = false;
        }
        this.adapter.on("scroll.waypoints", function() {
            if (!a.didScroll || d.isTouch) {
                a.didScroll = true;
                d.requestAnimationFrame(b);
            }
        });
    };
    /* Private */
    f.prototype.handleResize = function() {
        d.Context.refreshAll();
    };
    /* Private */
    f.prototype.handleScroll = function() {
        var a = {};
        var b = {
            horizontal: {
                newScroll: this.adapter.scrollLeft(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left"
            },
            vertical: {
                newScroll: this.adapter.scrollTop(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up"
            }
        };
        for (var c in b) {
            var d = b[c];
            var e = d.newScroll > d.oldScroll;
            var f = e ? d.forward : d.backward;
            for (var g in this.waypoints[c]) {
                var h = this.waypoints[c][g];
                var i = d.oldScroll < h.triggerPoint;
                var j = d.newScroll >= h.triggerPoint;
                var k = i && j;
                var l = !i && !j;
                if (k || l) {
                    h.queueTrigger(f);
                    a[h.group.id] = h.group;
                }
            }
        }
        for (var m in a) {
            a[m].flushTriggers();
        }
        this.oldScroll = {
            x: b.horizontal.newScroll,
            y: b.vertical.newScroll
        };
    };
    /* Private */
    f.prototype.innerHeight = function() {
        /*eslint-disable eqeqeq */
        if (this.element == this.element.window) {
            return d.viewportHeight();
        }
        /*eslint-enable eqeqeq */
        return this.adapter.innerHeight();
    };
    /* Private */
    f.prototype.remove = function(a) {
        delete this.waypoints[a.axis][a.key];
        this.checkEmpty();
    };
    /* Private */
    f.prototype.innerWidth = function() {
        /*eslint-disable eqeqeq */
        if (this.element == this.element.window) {
            return d.viewportWidth();
        }
        /*eslint-enable eqeqeq */
        return this.adapter.innerWidth();
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/context-destroy */
    f.prototype.destroy = function() {
        var a = [];
        for (var b in this.waypoints) {
            for (var c in this.waypoints[b]) {
                a.push(this.waypoints[b][c]);
            }
        }
        for (var d = 0, e = a.length; d < e; d++) {
            a[d].destroy();
        }
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/context-refresh */
    f.prototype.refresh = function() {
        /*eslint-disable eqeqeq */
        var a = this.element == this.element.window;
        /*eslint-enable eqeqeq */
        var b = this.adapter.offset();
        var c = {};
        var d;
        this.handleScroll();
        d = {
            horizontal: {
                contextOffset: a ? 0 : b.left,
                contextScroll: a ? 0 : this.oldScroll.x,
                contextDimension: this.innerWidth(),
                oldScroll: this.oldScroll.x,
                forward: "right",
                backward: "left",
                offsetProp: "left"
            },
            vertical: {
                contextOffset: a ? 0 : b.top,
                contextScroll: a ? 0 : this.oldScroll.y,
                contextDimension: this.innerHeight(),
                oldScroll: this.oldScroll.y,
                forward: "down",
                backward: "up",
                offsetProp: "top"
            }
        };
        for (var e in d) {
            var f = d[e];
            for (var g in this.waypoints[e]) {
                var h = this.waypoints[e][g];
                var i = h.options.offset;
                var j = h.triggerPoint;
                var k = 0;
                var l = j == null;
                var m, n, o;
                var p, q;
                if (h.element !== h.element.window) {
                    k = h.adapter.offset()[f.offsetProp];
                }
                if (typeof i === "function") {
                    i = i.apply(h);
                } else if (typeof i === "string") {
                    i = parseFloat(i);
                    if (h.options.offset.indexOf("%") > -1) {
                        i = Math.ceil(f.contextDimension * i / 100);
                    }
                }
                m = f.contextScroll - f.contextOffset;
                h.triggerPoint = k + m - i;
                n = j < f.oldScroll;
                o = h.triggerPoint >= f.oldScroll;
                p = n && o;
                q = !n && !o;
                if (!l && p) {
                    h.queueTrigger(f.backward);
                    c[h.group.id] = h.group;
                } else if (!l && q) {
                    h.queueTrigger(f.forward);
                    c[h.group.id] = h.group;
                } else if (l && f.oldScroll >= h.triggerPoint) {
                    h.queueTrigger(f.forward);
                    c[h.group.id] = h.group;
                }
            }
        }
        for (var r in c) {
            c[r].flushTriggers();
        }
        return this;
    };
    /* Private */
    f.findOrCreateByElement = function(a) {
        return f.findByElement(a) || new f(a);
    };
    /* Private */
    f.refreshAll = function() {
        for (var a in c) {
            c[a].refresh();
        }
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/context-find-by-element */
    f.findByElement = function(a) {
        return c[a.waypointContextKey];
    };
    window.onload = function() {
        if (e) {
            e();
        }
        f.refreshAll();
    };
    d.requestAnimationFrame = function(b) {
        var c = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || a;
        c.call(window, b);
    };
    d.Context = f;
})();

(function() {
    "use strict";
    function a(a, b) {
        return a.triggerPoint - b.triggerPoint;
    }
    function b(a, b) {
        return b.triggerPoint - a.triggerPoint;
    }
    var c = {
        vertical: {},
        horizontal: {}
    };
    var d = window.Waypoint;
    /* http://imakewebthings.com/waypoints/api/group */
    function e(a) {
        this.name = a.name;
        this.axis = a.axis;
        this.id = this.name + "-" + this.axis;
        this.waypoints = [];
        this.clearTriggerQueues();
        c[this.axis][this.name] = this;
    }
    /* Private */
    e.prototype.add = function(a) {
        this.waypoints.push(a);
    };
    /* Private */
    e.prototype.clearTriggerQueues = function() {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: []
        };
    };
    /* Private */
    e.prototype.flushTriggers = function() {
        for (var c in this.triggerQueues) {
            var d = this.triggerQueues[c];
            var e = c === "up" || c === "left";
            d.sort(e ? b : a);
            for (var f = 0, g = d.length; f < g; f += 1) {
                var h = d[f];
                if (h.options.continuous || f === d.length - 1) {
                    h.trigger([ c ]);
                }
            }
        }
        this.clearTriggerQueues();
    };
    /* Private */
    e.prototype.next = function(b) {
        this.waypoints.sort(a);
        var c = d.Adapter.inArray(b, this.waypoints);
        var e = c === this.waypoints.length - 1;
        return e ? null : this.waypoints[c + 1];
    };
    /* Private */
    e.prototype.previous = function(b) {
        this.waypoints.sort(a);
        var c = d.Adapter.inArray(b, this.waypoints);
        return c ? this.waypoints[c - 1] : null;
    };
    /* Private */
    e.prototype.queueTrigger = function(a, b) {
        this.triggerQueues[b].push(a);
    };
    /* Private */
    e.prototype.remove = function(a) {
        var b = d.Adapter.inArray(a, this.waypoints);
        if (b > -1) {
            this.waypoints.splice(b, 1);
        }
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/first */
    e.prototype.first = function() {
        return this.waypoints[0];
    };
    /* Public */
    /* http://imakewebthings.com/waypoints/api/last */
    e.prototype.last = function() {
        return this.waypoints[this.waypoints.length - 1];
    };
    /* Private */
    e.findOrCreate = function(a) {
        return c[a.axis][a.name] || new e(a);
    };
    d.Group = e;
})();

(function() {
    "use strict";
    var a = window.jQuery;
    var b = window.Waypoint;
    function c(b) {
        this.$element = a(b);
    }
    a.each([ "innerHeight", "innerWidth", "off", "offset", "on", "outerHeight", "outerWidth", "scrollLeft", "scrollTop" ], function(a, b) {
        c.prototype[b] = function() {
            var a = Array.prototype.slice.call(arguments);
            return this.$element[b].apply(this.$element, a);
        };
    });
    a.each([ "extend", "inArray", "isEmptyObject" ], function(b, d) {
        c[d] = a[d];
    });
    b.adapters.push({
        name: "jquery",
        Adapter: c
    });
    b.Adapter = c;
})();

(function() {
    "use strict";
    var a = window.Waypoint;
    function b(b) {
        return function() {
            var c = [];
            var d = arguments[0];
            if (b.isFunction(arguments[0])) {
                d = b.extend({}, arguments[1]);
                d.handler = arguments[0];
            }
            this.each(function() {
                var e = b.extend({}, d, {
                    element: this
                });
                if (typeof e.context === "string") {
                    e.context = b(this).closest(e.context)[0];
                }
                c.push(new a(e));
            });
            return c;
        };
    }
    if (window.jQuery) {
        window.jQuery.fn.waypoint = b(window.jQuery);
    }
    if (window.Zepto) {
        window.Zepto.fn.waypoint = b(window.Zepto);
    }
})();

// Headroom
$(".mast-head").headroom({
    onTop: function() {
        $(".hint").show();
    },
    offset: 100
});

// Break Apart
$(".grid").on("click", function() {
    $(this).toggleClass("break-apart");
});

$("#message").change(function(a) {
    if ($(this).val()) {
        $(this).next().hide();
    } else {
        $(this).next().show();
    }
});

(function() {
    $("body").addClass("tween");
})();

// Menu Trigger
(function() {
    $(".primary-menu-btn").on("click touchstart", function(a) {
        $("nav.primary").toggleClass("overlay");
        $(this).toggleClass("active");
        $(".mast-head").toggleClass("active");
        $(".site-logo").toggleClass("active");
        a.preventDefault();
    });
})();

// Logo Swap
$(".site-logo").hover(function() {
    var a = $(this);
    // caching $(this)
    a.data("Everhood", a.text());
    a.text("Kyle Langford");
}, function() {
    var a = $(this);
    // caching $(this)
    a.text(a.data("Everhood"));
});

//
// Waypoints.js
//
var waypoints = $(".squish").waypoint(function() {
    $(".squish").addClass("animate");
}, {
    offset: "40%"
});

var waypoints = $(".close-hint").waypoint(function() {
    $(".hint").hide();
}, {
    offset: "75%"
});

$(".span-tada").hide();

var waypoints = $(".wp-rotate").waypoint(function() {
    $(".span-tada").addClass("animated tada");
    $(".span-tada").fadeIn();
}, {
    offset: "50%"
});

// Scroll To
(function() {
    $.mark = {
        jump: function(a) {
            var b = {
                selector: "a.scroll-on-page-link"
            };
            if (typeof a == "string") {
                b.selector = a;
            }
            a = $.extend(b, a);
            return $(a.selector).click(function(a) {
                var b = $(this);
                var c = b.attr("href");
                var d = 1e3;
                var e = $(c).offset().top;
                $("html,body").animate({
                    scrollTop: e
                }, d, "swing");
                a.preventDefault();
            });
        }
    };
    $.mark.jump();
})();

// Show Alert
function showAlert(a, b) {
    $(b).append(a);
}

// Run when valid
var doOnce = true;

function validForm(a) {
    if (doOnce) {
        $(".submit").prop("disabled", false);
        doOnce = false;
    }
}

// Validation
$(".validate .input-field").on("keyup blur", function a() {
    var a = $(this).closest(" .validate");
    var b = a.find(".input-required");
    var c = b.length;
    var d = 0;
    var e = 1;
    b.each(function() {
        var a = $(this).val();
        if (a.length > e) {
            d += 1;
        }
    });
    if (d == c) {
        // console.log('valid');
        validForm(a);
        return true;
    }
});

// #( '.validate' ).submit( function( event ){
//   var killswitch = $('.killswitch').val();
//
//   console.log(killswitch);
//
//   if ( validate(this) ){
//     if ( killswitch.length < 0 ) {
// check killswitch
// timestamp
//
//
//       showAlert( '<p>Thank you for your attention, your email has been sent.</p>' , '.alert' );
//
//     }
//   }
// });
// Preload Elements
// window.onload = function() {
// 	setTimeout(function() {
// 		// XHR to request a JS and a CSS
// 		// var xhr = new XMLHttpRequest();
// 		// xhr.open('GET', 'http://domain.tld/preload.js');
// 		// xhr.send('');
//     // xhr = new XMLHttpRequest();
// 		// xhr.open('GET', 'http://domain.tld/preload.css');
// 		// xhr.send('');
// 		// preload image
// 		new Image().src = "img/danklin2012.jpg";
// 		new Image().src = "img/p-ballyribbon.jpg";
// 		new Image().src = "img/p-brunello.jpg";
// 		new Image().src = "img/p-imaginatik.jpg";
// 		new Image().src = "img/p-ma-ena.jpg";
// 		new Image().src = "img/p-orchard.jpg";
// 	}, 1000);
// };
$(function() {
    // Get the form.
    var a = $("#ajax-contact");
    // Get the messages div.
    var b = $("#form-messages");
    // Set up an event listener for the contact form.
    $(a).submit(function(c) {
        // Stop the browser from submitting the form.
        c.preventDefault();
        // Serialize the form data.
        var d = $(a).serialize();
        // Submit the form using AJAX.
        $.ajax({
            type: "POST",
            url: $(a).attr("action"),
            data: d
        }).done(function(a) {
            // Make sure that the formMessages div has the 'success' class.
            $(b).removeClass("error");
            $(b).addClass("success");
            // Set the message text.
            $(b).text(a);
            // Clear the form.
            $("#name").val("");
            $("#email").val("");
            $("#message").val("");
        }).fail(function(a) {
            // Make sure that the formMessages div has the 'error' class.
            $(b).removeClass("success");
            $(b).addClass("error");
            // Set the message text.
            if (a.responseText !== "") {
                $(b).text(a.responseText);
            } else {
                $(b).text("Oops! An error occured and your message could not be sent.");
            }
        });
    });
});