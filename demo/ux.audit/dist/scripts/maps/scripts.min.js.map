{"version":3,"sources":["angular-cache-buster.js","app.js","sortable.js"],"names":["angular","module","config","$httpProvider","interceptors","push","provider","this","matchlist","logRequests","black","setMatchlist","list","setLogRequests","$get","$q","$log","log","request","busted","i","length","url","match","d","Date","replace","indexOf","getTime","warn","info","when","app","constant","filter","value","$routeProvider","$locationProvider","templateUrl","otherwise","redirectTo","html5Mode","factory","$http","URL","getData","get","controller","DataService","$sce","ctrl","content","sortReverse","sortType","options","legend","display","loadSuggestion","fetchContent","then","result","data","console","impactCount","_","countBy","impactLabels","Object","keys","impactData","values","focusCount","focusLabels","focusData","effortCount","effortLabels","effortData","directive","$compile","buildLinks","title_string","url_string","title_array","split","url_array","linkbar","forEach","item","key","link","linker","scope","element","attrs","LinkHTML","asset","path","$","append","contents","restrict","template","uiSortableConfig","$timeout","require","ngModel","uiSortable","combineCallbacks","first","second","apply","arguments","getSortableWidgetInstance","widgetFullName","hasSortingHelper","ui","helperOption","sortable","isCustomHelperUsed","isFloating","test","css","getElementScope","elementScopes","x","afterStop","e","_destroy","savedNodes","opts","directiveOpts","ui-floating","undefined","callbacks","receive","remove","start","stop","update","wrappers","helper","extend","fn","jquery","$watch","siblings","sortableWidgetInstance","target","floating","model","$modelValue","index","source","parent","sourceModel","cancel","_isCanceled","isCanceled","_isCustomHelperUsed","activate","placeholder","phElement","excludes","find","attr","not","connectedSortables","_connectedSortables","received","dropindex","droptarget","droptargetScope","droptargetModel","last","appendTo","$apply","splice","moved","inner","innerResult","newVal","error"],"mappings":"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","file":"../scripts.min.js","sourcesContent":["angular.module('ngCacheBuster', [])\n  .config(['$httpProvider', function($httpProvider) {\n    return $httpProvider.interceptors.push('httpRequestInterceptorCacheBuster');\n  }])\n    .provider('httpRequestInterceptorCacheBuster', function() {\n\t\n\tthis.matchlist = [/.*partials.*/, /.*views.*/ ];\n\tthis.logRequests = false;\n\t\n\t//Default to whitelist (i.e. block all except matches)\n\tthis.black=false; \n\t\n\t//Select blacklist or whitelist, default to whitelist\n\tthis.setMatchlist = function(list,black) {\n\t    this.black = typeof black != 'undefined' ? black : false\n\t    this.matchlist = list;\n\t};\n\t\n\n\tthis.setLogRequests = function(logRequests) {\n\t    this.logRequests = logRequests;\n\t};\n\t\n\tthis.$get = ['$q', '$log', function($q, $log) {\n\t    var matchlist = this.matchlist;\n\t    var logRequests = this.logRequests;\n\t    var black = this.black;\n        if (logRequests) {\n            $log.log(\"Blacklist? \",black);\n        }\n\t    return {\n\t\t'request': function(config) {\n\t\t    //Blacklist by default, match with whitelist\n\t\t    var busted= !black; \n\t\t    \n\t\t    for(var i=0; i< matchlist.length; i++){\n\t\t\tif(config.url.match(matchlist[i])) {\n\t\t\t    busted=black; break;\n\t\t\t}\n\t\t    }\n\t\t    \n\t\t    //Bust if the URL was on blacklist or not on whitelist\n\t\t    if (busted) {\n\t\t\tvar d = new Date();\n\t\t\tconfig.url = config.url.replace(/[?|&]cacheBuster=\\d+/,'');\n\t\t\t//Some url's allready have '?' attached\n\t\t\tconfig.url+=config.url.indexOf('?') === -1 ? '?' : '&'\n\t\t\tconfig.url += 'cacheBuster=' + d.getTime();\n\t\t    }\n\t\t    \n\t\t    if (logRequests) {\n\t\t\tvar log='request.url =' + config.url\n\t\t\tbusted ? $log.warn(log) : $log.info(log)\n\t\t    }\n\n\t\t    return config || $q.when(config);\n\t\t}\n\t    }\n\t}];\n    });\n\n\n","var app = angular.module('UXAudit', [\n    'ui.sortable', \n    'ngRoute',\n    'chart.js',\n    ]);\n\napp.constant('URL', 'data/');\n\napp.filter('render', function () {\n  return function (value) {\n    return value;\n  };\n});\n\n\napp.config( function($routeProvider, $locationProvider) {\n  $routeProvider\n  .when('/', {\n    templateUrl: 'partials/view1.html'\n  })\n  .otherwise({ redirectTo: '/'});\n\n  // use the HTML5 History API\n  $locationProvider.html5Mode(true);\n\n});\n\napp.factory('DataService', function ($http, URL) {\n  var getData = function () {\n    return $http.get(URL + 'suggestions.json');\n  };\n\n  return {\n    getData: getData\n  };\n});\n\n\napp.controller('suggestionController', function (DataService, $sce) {\n    var ctrl = this;\n    ctrl.content = [];\n    ctrl.sortReverse = false;\n    ctrl.sortType = 'focus';\n    ctrl.options = {\n      legend: {\n        display: true,\n      }\n    }\n\n    ctrl.loadSuggestion = function () {\n      // do nothing\n    }\n\n    ctrl.fetchContent = function () {\n      DataService.getData().then(function (result) {\n\n        ctrl.content = result.data;\n        console.log(ctrl.content);\n\n        ctrl.impactCount = _.countBy(ctrl.content, 'impact');\n        ctrl.impactLabels = Object.keys(ctrl.impactCount);\n        ctrl.impactData = Object.values(ctrl.impactCount);\n\n        ctrl.focusCount = _.countBy(ctrl.content, 'focus');\n        ctrl.focusLabels = Object.keys(ctrl.focusCount);\n        ctrl.focusData = Object.values(ctrl.focusCount);\n\n        ctrl.effortCount = _.countBy(ctrl.content, 'effort');\n        ctrl.effortLabels = Object.keys(ctrl.effortCount);\n        ctrl.effortData = Object.values(ctrl.effortCount);\n\n      });\n\n    };\n\n    ctrl.fetchContent();\n\n});\n\n\napp.directive('linkblock', function ($compile, $http) {\n\n  var buildLinks = function ( title_string, url_string ) {\n\n    var title_array = title_string.split(',');\n    var url_array = url_string.split(',');\n    var linkbar = '';\n\n    url_array.forEach(function(item, key){\n      if (item !== '') {\n        var link = '<div class=\"link\"><a target=\"_blank\" href=\"';\n        link += item + '\">';\n        link += title_array[key] + '</a></div>';\n        linkbar += link;\n      } else {\n        linkbar += '';\n      }\n    });\n\n    return linkbar;\n  }\n\n  var linker = function (scope, element, attrs) {\n    var LinkHTML = buildLinks(scope.content.asset, scope.content.path);\n    $(element).append(LinkHTML);\n    $compile(element.contents())(scope);\n  }\n\n  return {\n    restrict: 'EA',\n    replace: true,\n    template: '',\n    link: linker,\n    scope: {\n      content: '<',\n    }\n  };\n});\n\n\n\n\n\n\n","/*\njQuery UI Sortable plugin wrapper\n\n@param [ui-sortable] {object} Options to pass to $.fn.sortable() merged onto ui.config\n*/\nangular.module('ui.sortable', [])\n.value('uiSortableConfig',{})\n.directive('uiSortable', [\n  'uiSortableConfig', '$timeout', '$log',\n  function(uiSortableConfig, $timeout, $log) {\n    return {\n      require: '?ngModel',\n      scope: {\n        ngModel: '=',\n        uiSortable: '='\n      },\n      link: function(scope, element, attrs, ngModel) {\n        var savedNodes;\n\n        function combineCallbacks(first,second){\n          if(second && (typeof second === 'function')) {\n            return function() {\n              first.apply(this, arguments);\n              second.apply(this, arguments);\n            };\n          }\n          return first;\n        }\n\n        function getSortableWidgetInstance(element) {\n          // this is a fix to support jquery-ui prior to v1.11.x\n          // otherwise we should be using `element.sortable('instance')`\n          var data = element.data('ui-sortable');\n          if (data && typeof data === 'object' && data.widgetFullName === 'ui-sortable') {\n            return data;\n          }\n          return null;\n        }\n\n        function hasSortingHelper (element, ui) {\n          var helperOption = element.sortable('option','helper');\n          return helperOption === 'clone' || (typeof helperOption === 'function' && ui.item.sortable.isCustomHelperUsed());\n        }\n\n        // thanks jquery-ui\n        function isFloating (item) {\n          return (/left|right/).test(item.css('float')) || (/inline|table-cell/).test(item.css('display'));\n        }\n\n        function getElementScope(elementScopes, element) {\n          var result = null;\n          for (var i = 0; i < elementScopes.length; i++) {\n            var x = elementScopes[i];\n            if (x.element[0] === element[0]) {\n              result = x.scope;\n              break;\n            }\n          }\n          return result;\n        }\n\n        function afterStop(e, ui) {\n          ui.item.sortable._destroy();\n        }\n\n        var opts = {};\n\n        // directive specific options\n        var directiveOpts = {\n          'ui-floating': undefined\n        };\n\n        var callbacks = {\n          receive: null,\n          remove:null,\n          start:null,\n          stop:null,\n          update:null\n        };\n\n        var wrappers = {\n          helper: null\n        };\n\n        angular.extend(opts, directiveOpts, uiSortableConfig, scope.uiSortable);\n\n        if (!angular.element.fn || !angular.element.fn.jquery) {\n          $log.error('ui.sortable: jQuery should be included before AngularJS!');\n          return;\n        }\n\n        if (ngModel) {\n\n          // When we add or remove elements, we need the sortable to 'refresh'\n          // so it can find the new/removed elements.\n          scope.$watch('ngModel.length', function() {\n            // Timeout to let ng-repeat modify the DOM\n            $timeout(function() {\n              // ensure that the jquery-ui-sortable widget instance\n              // is still bound to the directive's element\n              if (!!getSortableWidgetInstance(element)) {\n                element.sortable('refresh');\n              }\n            }, 0, false);\n          });\n\n          callbacks.start = function(e, ui) {\n            if (opts['ui-floating'] === 'auto') {\n              // since the drag has started, the element will be\n              // absolutely positioned, so we check its siblings\n              var siblings = ui.item.siblings();\n              var sortableWidgetInstance = getSortableWidgetInstance(angular.element(e.target));\n              sortableWidgetInstance.floating = isFloating(siblings);\n            }\n\n            // Save the starting position of dragged item\n            ui.item.sortable = {\n              model: ngModel.$modelValue[ui.item.index()],\n              index: ui.item.index(),\n              source: ui.item.parent(),\n              sourceModel: ngModel.$modelValue,\n              cancel: function () {\n                ui.item.sortable._isCanceled = true;\n              },\n              isCanceled: function () {\n                return ui.item.sortable._isCanceled;\n              },\n              isCustomHelperUsed: function () {\n                return !!ui.item.sortable._isCustomHelperUsed;\n              },\n              _isCanceled: false,\n              _isCustomHelperUsed: ui.item.sortable._isCustomHelperUsed,\n              _destroy: function () {\n                angular.forEach(ui.item.sortable, function(value, key) {\n                  ui.item.sortable[key] = undefined;\n                });\n              }\n            };\n          };\n\n          callbacks.activate = function(e, ui) {\n            // We need to make a copy of the current element's contents so\n            // we can restore it after sortable has messed it up.\n            // This is inside activate (instead of start) in order to save\n            // both lists when dragging between connected lists.\n            savedNodes = element.contents();\n\n            // If this list has a placeholder (the connected lists won't),\n            // don't inlcude it in saved nodes.\n            var placeholder = element.sortable('option','placeholder');\n\n            // placeholder.element will be a function if the placeholder, has\n            // been created (placeholder will be an object).  If it hasn't\n            // been created, either placeholder will be false if no\n            // placeholder class was given or placeholder.element will be\n            // undefined if a class was given (placeholder will be a string)\n            if (placeholder && placeholder.element && typeof placeholder.element === 'function') {\n              var phElement = placeholder.element();\n              // workaround for jquery ui 1.9.x,\n              // not returning jquery collection\n              phElement = angular.element(phElement);\n\n              // exact match with the placeholder's class attribute to handle\n              // the case that multiple connected sortables exist and\n              // the placehoilder option equals the class of sortable items\n              var excludes = element.find('[class=\"' + phElement.attr('class') + '\"]:not([ng-repeat], [data-ng-repeat])');\n\n              savedNodes = savedNodes.not(excludes);\n            }\n\n            // save the directive's scope so that it is accessible from ui.item.sortable\n            var connectedSortables = ui.item.sortable._connectedSortables || [];\n\n            connectedSortables.push({\n              element: element,\n              scope: scope\n            });\n\n            ui.item.sortable._connectedSortables = connectedSortables;\n          };\n\n          callbacks.update = function(e, ui) {\n            // Save current drop position but only if this is not a second\n            // update that happens when moving between lists because then\n            // the value will be overwritten with the old value\n            if(!ui.item.sortable.received) {\n              ui.item.sortable.dropindex = ui.item.index();\n              var droptarget = ui.item.parent();\n              ui.item.sortable.droptarget = droptarget;\n\n              var droptargetScope = getElementScope(ui.item.sortable._connectedSortables, droptarget);\n              ui.item.sortable.droptargetModel = droptargetScope.ngModel;\n\n              // Cancel the sort (let ng-repeat do the sort for us)\n              // Don't cancel if this is the received list because it has\n              // already been canceled in the other list, and trying to cancel\n              // here will mess up the DOM.\n              element.sortable('cancel');\n            }\n\n            // Put the nodes back exactly the way they started (this is very\n            // important because ng-repeat uses comment elements to delineate\n            // the start and stop of repeat sections and sortable doesn't\n            // respect their order (even if we cancel, the order of the\n            // comments are still messed up).\n            if (hasSortingHelper(element, ui) && !ui.item.sortable.received &&\n                element.sortable( 'option', 'appendTo' ) === 'parent') {\n              // restore all the savedNodes except .ui-sortable-helper element\n              // (which is placed last). That way it will be garbage collected.\n              savedNodes = savedNodes.not(savedNodes.last());\n            }\n            savedNodes.appendTo(element);\n\n            // If this is the target connected list then\n            // it's safe to clear the restored nodes since:\n            // update is currently running and\n            // stop is not called for the target list.\n            if(ui.item.sortable.received) {\n              savedNodes = null;\n            }\n\n            // If received is true (an item was dropped in from another list)\n            // then we add the new item to this list otherwise wait until the\n            // stop event where we will know if it was a sort or item was\n            // moved here from another list\n            if(ui.item.sortable.received && !ui.item.sortable.isCanceled()) {\n              scope.$apply(function () {\n                ngModel.$modelValue.splice(ui.item.sortable.dropindex, 0,\n                                           ui.item.sortable.moved);\n              });\n            }\n          };\n\n          callbacks.stop = function(e, ui) {\n            // If the received flag hasn't be set on the item, this is a\n            // normal sort, if dropindex is set, the item was moved, so move\n            // the items in the list.\n            if(!ui.item.sortable.received &&\n               ('dropindex' in ui.item.sortable) &&\n               !ui.item.sortable.isCanceled()) {\n\n              scope.$apply(function () {\n                ngModel.$modelValue.splice(\n                  ui.item.sortable.dropindex, 0,\n                  ngModel.$modelValue.splice(ui.item.sortable.index, 1)[0]);\n              });\n            } else {\n              // if the item was not moved, then restore the elements\n              // so that the ngRepeat's comment are correct.\n              if ((!('dropindex' in ui.item.sortable) || ui.item.sortable.isCanceled()) &&\n                  !hasSortingHelper(element, ui)) {\n                savedNodes.appendTo(element);\n              }\n            }\n\n            // It's now safe to clear the savedNodes\n            // since stop is the last callback.\n            savedNodes = null;\n          };\n\n          callbacks.receive = function(e, ui) {\n            // An item was dropped here from another list, set a flag on the\n            // item.\n            ui.item.sortable.received = true;\n          };\n\n          callbacks.remove = function(e, ui) {\n            // Workaround for a problem observed in nested connected lists.\n            // There should be an 'update' event before 'remove' when moving\n            // elements. If the event did not fire, cancel sorting.\n            if (!('dropindex' in ui.item.sortable)) {\n              element.sortable('cancel');\n              ui.item.sortable.cancel();\n            }\n\n            // Remove the item from this list's model and copy data into item,\n            // so the next list can retrive it\n            if (!ui.item.sortable.isCanceled()) {\n              scope.$apply(function () {\n                ui.item.sortable.moved = ngModel.$modelValue.splice(\n                  ui.item.sortable.index, 1)[0];\n              });\n            }\n          };\n\n          wrappers.helper = function (inner) {\n            if (inner && typeof inner === 'function') {\n              return function (e, item) {\n                var innerResult = inner.apply(this, arguments);\n                item.sortable._isCustomHelperUsed = item !== innerResult;\n                return innerResult;\n              };\n            }\n            return inner;\n          };\n\n          scope.$watch('uiSortable', function(newVal /*, oldVal*/) {\n            // ensure that the jquery-ui-sortable widget instance\n            // is still bound to the directive's element\n            var sortableWidgetInstance = getSortableWidgetInstance(element);\n            if (!!sortableWidgetInstance) {\n              angular.forEach(newVal, function(value, key) {\n                // if it's a custom option of the directive,\n                // handle it approprietly\n                if (key in directiveOpts) {\n                  if (key === 'ui-floating' && (value === false || value === true)) {\n                    sortableWidgetInstance.floating = value;\n                  }\n\n                  opts[key] = value;\n                  return;\n                }\n\n                if (callbacks[key]) {\n                  if( key === 'stop' ){\n                    // call apply after stop\n                    value = combineCallbacks(\n                      value, function() { scope.$apply(); });\n\n                    value = combineCallbacks(value, afterStop);\n                  }\n                  // wrap the callback\n                  value = combineCallbacks(callbacks[key], value);\n                } else if (wrappers[key]) {\n                  value = wrappers[key](value);\n                }\n\n                opts[key] = value;\n                element.sortable('option', key, value);\n              });\n            }\n          }, true);\n\n          angular.forEach(callbacks, function(value, key) {\n            opts[key] = combineCallbacks(value, opts[key]);\n            if( key === 'stop' ){\n              opts[key] = combineCallbacks(opts[key], afterStop);\n            }\n          });\n\n        } else {\n          $log.info('ui.sortable: ngModel not provided!', element);\n        }\n\n        // Create sortable\n        element.sortable(opts);\n      }\n    };\n  }\n]);"]}